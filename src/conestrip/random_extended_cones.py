# Copyright 2021 Wieger Wesselink.
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE or http://www.boost.org/LICENSE_1_0.txt)

# Functions for generating random cones. They operate on extended cones.

import random
from fractions import Fraction
from typing import Tuple, Optional

from more_itertools import flatten
from z3 import Real, ForAll, Implies, And, Not, Solver, sat, simplify

from conestrip.cones import Gamble, ConvexCombination
from conestrip.conestrip_z3 import conestrip1_constraints
from conestrip.extended_cones import ExtendedConeGenerator, ExtendedGeneralCone
from conestrip.random_cones import remove_redundant_vertices, random_cone_generator, random_inside_point


def random_inside_point_extended(R: ExtendedConeGenerator) -> Tuple[Gamble, ConvexCombination]:
    """
    Generates a random point that is inside the cone generated by R
    @param R:
    @return:
    """
    return random_inside_point(R.to_cone_generator())


def random_border_point_extended(R: ExtendedConeGenerator) -> Tuple[Gamble, ConvexCombination]:
    """
    Generates a random point that is in the border of the cone generated by R
    @param R:
    @return:
    """
    n = len(R.gambles[0])

    if len(R.gambles) == 1:
        return [Fraction(0)] * n, [Fraction(0)]

    # converts indices to points
    def make_facet(indices: Tuple[int]) -> ExtendedConeGenerator:
        return ExtendedConeGenerator([R.vertices[i] for i in indices])

    facet = random.choice(R.facets)  # contains the indices of the vertices
    border_facet = make_facet(facet)
    facet = list(facet)

    # if the border facet has the same dimension, remove a random vertex
    if len(border_facet.gambles) == len(R.gambles):
        m = len(border_facet.gambles)
        i = random.randint(0, m - 1)
        facet.pop(i)
        border_facet.gambles.pop(i)

    x, lambda_ = random_inside_point_extended(border_facet)
    coefficients = [Fraction(0)] * len(R.gambles)
    for i, j in enumerate(facet):
        coefficients[j] = lambda_[i]
    return x, coefficients


def add_random_border_cone_extended(R: ExtendedConeGenerator) -> ExtendedConeGenerator:
    # converts indices to points
    def make_facet(indices: Tuple[int]) -> ExtendedConeGenerator:
        return ExtendedConeGenerator([R.vertices[i] for i in indices])

    facet = random.choice(R.facets)
    facet_index = R.facets.index(facet)
    border_facet = make_facet(facet)

    # generate a cone that is contained in border_face
    m = len(border_facet.gambles)
    result = []
    for i in range(m):
        g, lambda_ = random_inside_point_extended(border_facet)
        result.append(g)

    generator = ExtendedConeGenerator(remove_redundant_vertices(result))
    generator.parent = (R, facet_index)
    R.children[facet_index].append(generator)
    return generator


def add_random_border_cones_extended(R: ExtendedGeneralCone, n: int, allow_multiple_children: bool = False) -> None:
    """
    Adds randomly generated border cones to a general cone. The algorithm randomly selects a border facet of a cone
    generator, and then generates a new facet that is included in this border facet. The new facet is added to the
    general cone. This process is repeated a number of times.
    @param R: a general cone
    @param n: the number of border cones that is added
    @param allow_multiple_children: if true, a border facet can be selected multiple times
    @return:
    """
    def is_allowed(r: ExtendedConeGenerator) -> bool:
        if len(r.gambles) < 2:
            return False
        if allow_multiple_children:
            return True
        for _, successors in enumerate(r.children):
            if not successors:
                return True
        return False

    for i in range(n):
        R1 = [r for r in R.generators if is_allowed(r)]
        r = random.choice(R1)
        generator = add_random_border_cone_extended(r)
        R.generators.append(generator)


def random_cone_generator_extended(dimension: int, generator_size: int, bound: int, normal=None) -> ExtendedConeGenerator:
    return ExtendedConeGenerator(random_cone_generator(dimension, generator_size, bound, normal))


def random_general_cone_extended(cone_size: int, dimension: int, generator_size: int, bound: int) -> ExtendedGeneralCone:
    return ExtendedGeneralCone([random_cone_generator_extended(dimension, generator_size, bound) for _ in range(cone_size)])


def random_between_point_extended(R1: ExtendedConeGenerator, verbose: bool = False) -> Optional[Tuple[Gamble, ConvexCombination]]:
    """
    Generates a point that is contained in R1.parent, but not in R1.
    @precondition R1.parent != None
    @param R1: A cone generator
    """

    R0, facet_index = R1.parent

    n = len(R1.gambles[0])
    Omega_Gamma = list(range(n))
    Omega_Delta = list(range(n))

    cone0 = [R0.to_cone_generator()]
    cone1 = [R1.to_cone_generator()]

    # variables
    f = [Real(f'f{d}') for d in range(n)]
    lambda0 = [Real(f'lambda0{d}') for d in range(len(cone0))]
    nu0 = [[Real(f'nu0_{d}_{i}') for i in range(len(cone0[d]))] for d in range(len(cone0))]
    lambda1 = [Real(f'lambda1{d}') for d in range(len(cone1))]
    nu1 = [[Real(f'nu1_{d}_{i}') for i in range(len(cone1[d]))] for d in range(len(cone1))]

    # f is inside R0, and not inside R1
    constraints0 = list(flatten(conestrip1_constraints(cone0, f, Omega_Gamma, Omega_Delta, (lambda0, nu0), verbose)))
    lambda_nu_constraints, omega_constraints = conestrip1_constraints(cone1, f, Omega_Gamma, Omega_Delta, (lambda1, nu1), verbose)
    constraint1 = ForAll(lambda1 + list(flatten(nu1)), Implies(And(lambda_nu_constraints), Not(And(omega_constraints))))
    constraints = constraints0 + [constraint1]

    solver = Solver()
    solver.add(constraints)
    if solver.check() == sat:
        model = solver.model()
        lambda0_solution = [model.evaluate(lambda0[d]) for d in range(len(cone0))]
        lambda1_solution = [model.evaluate(lambda1[d]) for d in range(len(cone1))]
        nu0_solution = [[model.evaluate(nu0[d][i]) for i in range(len(cone0[d]))] for d in range(len(cone0))]
        nu1_solution = [[model.evaluate(nu1[d][i]) for i in range(len(cone1[d]))] for d in range(len(cone1))]
        f = [model.evaluate(f[d]) for d in range(len(f))]
        if verbose:
            print('--- solution ---')
            print('lambda0 =', lambda0_solution)
            print('nu0 =', nu0_solution)
            print('lambda1 =', lambda1_solution)
            print('nu1 =', nu1_solution)
        coefficients = [simplify(x) for x in nu0_solution[0]]
        return f, coefficients
    return None
